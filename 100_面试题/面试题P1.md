# 1. `==` 和 `is` 的区别？

**==** 比较的是两个对象的内容是否相等，默认会调用对象的 **__eq__()** 方法。

**is** 比较的是两个对象的 id 是否相等，也就是是否是同一个对象，是否指向同一个内存地址。



# 2. 进程和线程的区别？

- 进程是操作系统`分配资源`的最小单元，线程是操作系统`调度`的最小单元
- 进程间切换代价大，线程间切换代价小
- 进程拥有的资源多，线程拥有的资源少
- 每个进程在执行过程中拥有独立的内存单元，而一个进程中的多个线程在执行过程中共享内存。



# 3. 一行代码实现1~100求和

~~~python
sum(range(1,101))
~~~



# 4. 如何在一个函数内部修改全局变量?

利用 `global` 在函数内部声明 修改全局变量

~~~python
a = 5
def fn()
	global a
	a = 7
~~~



# 5. 列出5个Python标准库?

- os  提供与操作系统相关的函数
- re     正则匹配
- random  生成随机数
- itertools  提供了一些关于迭代运算的基础函数
- functools  提供了许多改写或拓展函数或其他可调用对象的工具



# 6. 字典如何删除键和合并两个字典?

删除 `del`

合并 `|=` 或者 `update`

~~~python
dict1 = {1: "a", 2: "b", 5: "e"}
dict2 = {3: "c", 4: "d"}

del dict1[5]

dict1.update(dict2)
print(dict1)
dict1 |= dict2
print(dict1)
~~~



# 7. 谈下Python的GIL?

## 什么是GIL?

GIL是python的`全局解释器锁`，同一个进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器(加一把锁即GIL),使该进程内的其他线程无法运行，等该线程运行完成后，其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。

所以在多线程中，线程的运行仍然是有先后顺序的，并不是同时进行。

`多进程`中因为每个进程都能被系统分配资源，相当于`每个进程有了一个python解释器`，所以多进程可以实现多个进程的同时运行，缺点是`进程系统资源开销大`

GIL是一个`互斥锁（mutex）`。它阻止了多个线程同时执行Python字节码，毫无疑问，这降低了执行效率。



## GIL的产生？

多个线程同时对数据进行操作，会引发数据不一致，导致 `内存泄漏` ，所以CPython创建了GIL锁。



## GIL带来的问题

1. 死锁  线程间互相争抢锁的资源
2. 反复获取和释放锁而导致的性能降低



对于`IO密集型`应用，多线程的应用和多进程应用区别不大。即便有GIL存在，由于IO操作会导致GIL释放，其他线程能够获得执行权限。由于多线程的通讯成本低于多进程，因此偏向使用多线程。

对于`计算密集型`应用，由于CPU一直处于被占用状态，GIL锁直到规定时间才会释放，然后才会切换状态，导致多线程处于绝对的劣势，此时可以采用多进程+协程。



# 8. 列表去重的方法?

先转换为set集合，再转换为列表

~~~python
list1 = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
list(set(list1))
# 返回[1, 2, 3, 4, 5]
~~~



# 9. fun(\*args, \*\*kargs)中\*args和\*\*kargs的含义？

用于函数定义，表示可以接收不定数量参数的函数。

*args 用来接收非键值对的参数，保存在args这个元组中

*kargs 用来接收键值对类型的参数，保存在kwargs这个字典中

~~~python
def test(*args, **kwargs):
    print(f"args: {args}, type: {type(args)}")
    print(f"kwargs: {kwargs}, type: {type(kwargs)}")


print(test(1, 2, 3, 4, 5, a=1, b=2, c=3))

# 打印结果
# args: (1, 2, 3, 4, 5), type: <class 'tuple'>
# kwargs: {'a': 1, 'b': 2, 'c': 3}, type: <class 'dict'>
# None
~~~



# 10. Python2和Python3的range(100)的区别？

python2直接返回列表，python3返回迭代器，节约内存



# 11.  一句话解释什么样的语言能够使用装饰器？

函数能作为参数传递的语言，可以使用装饰器



# 12. 内建数据类型有哪些？

- 数字      int,float,complex   不可变     
- 字符串   str                         不可变      有序
- 列表       list                        可变           有序
- 元组       tuple                     不可变        有序
- 集合        set                       可变             无序
- 字典        dict                      可变              有序



| 类型         | 内置数据类型                       | 特点                                                         |
| ------------ | ---------------------------------- | ------------------------------------------------------------ |
| 文本类型：   | `str`                              | 不可变，有序                                                 |
| 数值类型：   | `int`, `float`, `complex`          | 不可变                                                       |
| 序列类型：   | `list`, `tuple`, `range`           | 有序，list可变，tunple不可变，range不可变的数字序列          |
| 映射类型：   | `dict`                             | 可变，有序，key不重复，value可重复                           |
| 集合类型：   | `set`, `frozenset`                 | 无序，不重复，存储可哈希(不可变)类型，set可变, frozenset不可变；可以使用集合运算符 `| 并集` `& 交集 `  `^ 对称差集(交集取反)` `- 差集` |
| 布尔类型：   | `bool`                             | `True` 或 `False`                                            |
| 二进制类型： | `bytes`, `bytearray`, `memoryview` |                                                              |



~~~python
# 数据类型
print(type(100))
print(type(0.1))
print(type(1.5j))
print(type(True))
print(type("True"))
print(type([1, 2, 3]))
print(type((1, 2, 3)))
print(type({1, 2, 3}))
print(type({1: "a", 2: "b", 3: "c"}))

<class 'int'>
<class 'float'>
<class 'complex'>
<class 'bool'>
<class 'str'>
<class 'list'>
<class 'tuple'>
<class 'set'>
<class 'dict'>
~~~



# 13. 面向对象中\_\_init\_\_和\_\_new\_\_的区别

`__init__`  `初始方法`，创建对象后，立即被默认调用（用于初始化变量）；`在类实例创建之后调用`

`__new__`     `实例化方法`，创建对象时，第一个被默认调用，用于返回对象

可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例

 至少要有一个参数cls代表当前类，此参数在实例化时由解释器自动识别；必须要有返回值，返回实例化出来的对象；



​                     

# 14. with方法打开文件帮我们做了什么?

- 不使用with

1. 打开不存在的文件会报错 

2. 最后需要关闭文件，释放资源

```python
f = open("test.txt2", "r", encoding="utf-8")
print(f.read())
f.close()
# FileNotFoundError: [Errno 2] No such file or directory: 'test.txt2'

try:
    f = open("test.txt2", "r", encoding="utf-8")
    print(f.read())
except:
    print("文件不存在")
finally:
    if f:
        f.close()
```



- 使用with

当文件不存在时，自动创建文件

with 方法不管使用过程中是否发生异常，都会自动帮我们执行清理操作

如 `f.close` 释放资源，文件关闭，线程中锁的自动获取和释放



# 15. list[1，2，3，4，5]使用map函数输出[1，4，9，16，25]，使用列表推导式取出大于10的数

```python
list3 = [1, 2, 3, 4, 5]
result1 = list(map(lambda x: x ** 2, list3))
print(result1) # [1, 4, 9, 16, 25]
result2 = [i for i in result1 if i > 10]
print(result2) # [16, 25]
```





# 16. 生成随机整数，和随机0~1浮点数

随机整数

```python
import random
random.randint(0, 100)
```



随机浮点

```python
random.random()
```















